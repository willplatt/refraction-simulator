package RefractionSim;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.io.IOException;
import java.util.Hashtable;
import javax.swing.*;
import javax.swing.border.TitledBorder;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 * Class for objects that generate the user interface
 * @author William Platt
 *
 */
public class UIController {
	private Viewport viewport;
	private JMenuBar menuBar;
	private JPanel propertiesPanel;
	private int fullWidth;
	private int fullHeight;
	private final static int PROPS_PANEL_WIDTH = 250;
	
	/**
	 * Constructor for the UIController class which generates the viewport, menu bar and properties panel
	 * @param window the window which will contain this new viewport, menu bar and properties panel
	 */
	public UIController(RefractionSimulator window) {
		fullWidth = (int)(window.getWidth() - window.getInsets().left - window.getInsets().right); // Store the width of the inside of the window
		fullHeight = (int)(window.getHeight() - window.getInsets().top - window.getInsets().bottom); // Store the height of the inside of the window
		createViewport();
		RayBox rayBox1 = new RayBox();
		viewport.addRayBox(rayBox1);
		createMenuBar();
		buildPropertiesPanel(rayBox1);
	}
	
	/**
	 * Generates a viewport to fill all of the space in the window left by the properties panel and menu bar. The viewport can then be retrieved using getViewport().
	 */
	private void createViewport() {
		// Create a menu bar to find out how tall the real menu bar will be and therefore how much space there is for the viewport
		JMenuBar dummyMenuBar = new JMenuBar();
		dummyMenuBar.add(new JMenu("File"));
		viewport = new Viewport(fullWidth - PROPS_PANEL_WIDTH, fullHeight - (int)(dummyMenuBar.getPreferredSize().getHeight()));
	}
	
	/**
	 * Returns the generated viewport
	 * @return the viewport that was generated by createViewport()
	 */
	public Viewport getViewport() {
		return viewport;
	}
	
	/**
	 * Class for dialog boxes which allow the user to save an image
	 * @author William Platt
	 *
	 */
	private class FileSaver extends JFileChooser {
		
		private String gifDescription = "GIF image (limited colour pallete but small file sizes)";
		private String pngDescription = "PNG image (low compression and large file sizes)";
		private String jpgDescription = "JPEG image (high compression more suited to photographs)";
		
		/**
		 * Constructor for the FileSaver class which sets the allowable file formats and sets gif as the default
		 */
		public FileSaver() {
			super();
			FileNameExtensionFilter gifFilter = new FileNameExtensionFilter(gifDescription, "gif");
			addChoosableFileFilter(gifFilter);
			addChoosableFileFilter(new FileNameExtensionFilter(pngDescription, "png"));
			addChoosableFileFilter(new FileNameExtensionFilter(jpgDescription, "jpg"));
			setAcceptAllFileFilterUsed(false);
			setFileFilter(gifFilter);
		}
		
		/**
		 * Called when the user clicks 'Save' to open a dialog box if a file already exists with this name in this directory
		 */
		@Override
		public void approveSelection() {
			boolean approveFileName = false;
			File newFile = getFileWithExtension();
			System.out.println(newFile.getName());
			if (newFile.getName().matches(".*[\\\\/?<>:|\"%*].*")) { // If the filename contains any invalid characters
				JOptionPane.showMessageDialog(this, "The filename entered was invalid; the following characters are not allowed: \\ / ? < > : | \" % *");
			} else if (newFile.exists()) { // If a file with this name and directory already exists, ask the user if they would like to overwrite it
				int overwriteReturn = JOptionPane.showConfirmDialog(this, "A file with this name already exists, would you like to overwrite it?", "File already exists", JOptionPane.YES_NO_OPTION);
				if (overwriteReturn == JOptionPane.YES_OPTION) { // If the user chose to overwrite the file
					approveFileName = true;
				}
			} else {
				approveFileName = true;
			}
			if (approveFileName) {
				try {
					if (newFile.createNewFile()) { // Attempts to create the new file (with no contents) and returns true if it is created successfully
						super.approveSelection(); // Allow the dialog to close and the showSaveDialog() method to return APPROVE_OPTION
					}
				} catch (IOException e) { // Display a dialog if the empty file couldn't be created
					JOptionPane.showMessageDialog(this, "There was a problem saving the image; you might not have permission to save to the directory you chose.");
				}
			}
		}
		
		/**
		 * Returns a file (with the file extension included in its path) into which image data can be written
		 * @return a file (with the file extension included in its path) into which image data can be written
		 */
		public File getFileWithExtension() {
			File newFile = getSelectedFile(); // Get the path of the new file including the name entered by the user
			System.out.println(newFile.getName());
			System.out.println();
			String fileExtension = extensionFromFileName(newFile.getName());
			if ((!fileExtension.equals("png")) && (!fileExtension.equals("jpg")) && (!fileExtension.equals("gif"))) { // If the user did not add a valid file extension to the file's name
				fileExtension = getFileFilter().getDescription(); // Get the description of the file format that was selected from the drop down menu when the user clicked 'Save'
				if (fileExtension.equals(gifDescription)) {
					fileExtension = "gif";
				} else if (fileExtension.equals(pngDescription)) {
					fileExtension = "png";
				} else {
					fileExtension = "jpg";
				}
				newFile = new File(newFile.getPath() + "." + fileExtension); // Add the file extension of the selected file format to the end of the file name
			}
			return newFile;
		}
		
		/**
		 * Returns the string of characters after the last "." in fileName in lower case; if there is no "." in fileName then "" will be returned
		 * @param fileName the name or path of a file
		 * @return the file extension of the file name (characters after the last "." in lower case) or an empty string
		 */
		public String extensionFromFileName(String fileName) {
			String[] substrings = fileName.split("\\."); // The split parameter string represents a regular expression, so the . must be escaped
			if (substrings.length > 0) {
				return substrings[substrings.length - 1].toLowerCase(); // Return everything after the last . (converted to lower case)
			} else {
				return "";
			}
		}
		
	}
	
	/**
	 * Generates a menu bar which can then be retrieved using getMenuBar()
	 */
	public void createMenuBar() {
		menuBar = new JMenuBar();
		menuBar.add(getFileMenu());
		menuBar.add(getAddMenu());
		addTargetWorldMenus(menuBar);
		menuBar.add(getViewMenu());
	}
	
	/**
	 * Generates and returns the File menu which is to be added to the menu bar
	 * @return the File menu
	 */
	private JMenu getFileMenu() {
		JMenu fileMenu = new JMenu("File");
		JMenuItem saveImage = new JMenuItem("Save as image", KeyEvent.VK_S); // Allows the user to click 'S' as a shortcut when the file menu is open (the 'S' in save is also underlined to indicate this)
		saveImage.addActionListener(new ActionListener() { // Use adapter class rather than making a new class
			
			/**
			 * Called when the saveImage menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				FileSaver fileSaver = new FileSaver();
				int saveFileReturn = fileSaver.showSaveDialog(SwingUtilities.windowForComponent(viewport));
				if (saveFileReturn == FileSaver.APPROVE_OPTION) { // If the user clicked save rather than cancel or closing the dialog box
					File newFile = fileSaver.getFileWithExtension();
					viewport.saveImage(newFile, fileSaver.extensionFromFileName(newFile.getName())); // Write the image file to newFile
				}
			}
			
		});
		fileMenu.add(saveImage);
		return fileMenu;
	}
	
	/**
	 * Generates and returns the Add menu which is to be added to the menu bar
	 * @return the Add menu
	 */
	private JMenu getAddMenu() {
		JMenu addMenu = new JMenu("Add");
		JMenuItem addRayBox = new JMenuItem("Ray box", KeyEvent.VK_R); // Shortcut is 'R'
		ActionListener addRayBoxListener = new ActionListener() { // Use an adapter class
			
			/**
			 * Called when the addRayBox menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				RayBox newRayBox = new RayBox();
				viewport.addRayBox(newRayBox);
			}
			
		};
		addRayBox.addActionListener(addRayBoxListener);
		addMenu.add(addRayBox);
		JMenuItem addMaterial = new JMenuItem("Custom material", KeyEvent.VK_C); // Shortcut is 'C'
		addMaterial.addActionListener(new ActionListener() { // Use an adapter class
			
			/**
			 * Called when the addMaterial menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				JTextField materialNameField = new JTextField();
				MaterialNameActionListener matNameActionListener = new MaterialNameActionListener();
				materialNameField.addActionListener(matNameActionListener);
				materialNameField.addFocusListener(new TextFieldFocusListener(matNameActionListener)); // The TextFieldFocusListener requires the ActionListener so that it can trigger an ActionEvent when a FocusEvent occurs
				JTextField refractiveIndexField = new JTextField("1.0"); // Pre-populate the field with a value of 1.0
				RefractiveIndexActionListener refIndexActionListener = new RefractiveIndexActionListener("1.0");
				refractiveIndexField.addActionListener(refIndexActionListener);
				refractiveIndexField.addFocusListener(new TextFieldFocusListener(refIndexActionListener));
				JComponent[] inputs = new JComponent[] {
						new JLabel("Material name:"),
						materialNameField,
						new JLabel("Refractive index:"),
						refractiveIndexField
				};
				int choice = JOptionPane.showOptionDialog(SwingUtilities.windowForComponent(viewport), inputs, "Add a custom material", JOptionPane.CANCEL_OPTION, JOptionPane.PLAIN_MESSAGE, null, null, null); // PLAIN_MESSAGE allows me to pass a message rather than use a standard message; in this case the message is a list of components (JLabels and JTextFields)
				if (choice == JOptionPane.OK_OPTION) { // Only add the material if the user clicked OK
					String name = materialNameField.getText().trim(); // Get the material name entered and remove whitespace from the beginning and end of the material name
					if (name.equals("")) { // Strings are objects, so == won't be true unless both sides refer to the same memory location
						name = "Custom material"; // Replace a blank name with "Custom material"
					}
					viewport.addMaterial(name, Double.parseDouble(refractiveIndexField.getText())); // Add the material to the list; the refractive index field's listeners will have ensured that its value is a number
				}
			}
			
		});
		addMenu.add(addMaterial);
		return addMenu;
	}
	
	/**
	 * Generates the Target and World menus and adds them to the menu bar. This method is more efficient than generating the menus separately because the target's Material menu and the World menu are similar
	 * @param menuBar the menu bar which the menus are to be added to
	 */
	private void addTargetWorldMenus(JMenuBar menuBar) {
		JMenu targetMenu = new JMenu("Target");
		JMenu targetShapeMenu = new JMenu("Shape"); // This will be a submenu of the Target menu; it will automatically expand when the cursor is over it or its shortcut is used with the Target menu open
		targetShapeMenu.setMnemonic(KeyEvent.VK_S); // Set the shortcut to 'S' and underline the 'S' in Shape; this can't be done in the constructor like it can be for JMenuItems
		ButtonGroup shapeRadioButtons = new ButtonGroup(); // Radio buttons must be grouped so that no more than one can be selected at a time; the selected radio button is then automatically handled when one is clicked
		Mesh.Primitive[] shapes = Mesh.Primitive.values(); // Store a list of all primitive meshes
		ActionListener shapeActionListener = new ActionListener() { // Use an adapter class
			
			/**
			 * Called when a radio button/menu item in the Shape menu is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				JRadioButtonMenuItem source = (JRadioButtonMenuItem)(event.getSource()); // Get the menu item selected and typecast it to a JRadioButtonMenuItem
				viewport.setTargetShape(Mesh.primitiveFromStr(source.getText())); // Convert the text of the selected menu item into a mesh primitive which the viewport will set the target's shape to
			}
			
		};
		for (Mesh.Primitive shape : shapes) { // Set shape to each element of shapes in turn
			String checkBoxLabel = shape.toString(); // Get the corresponding string for the mesh primitive
			JRadioButtonMenuItem shapeMenuItem = new JRadioButtonMenuItem(checkBoxLabel); // Set the text of the menu item to the string for the mesh primitive
			if (viewport.getTargetShape() == checkBoxLabel) { // Select the radio button matching the target's current shape
				shapeMenuItem.setSelected(true);
			}
			shapeMenuItem.addActionListener(shapeActionListener); // Add the ActionListener to each radio button
			shapeRadioButtons.add(shapeMenuItem);
			targetShapeMenu.add(shapeMenuItem);
		}
		targetMenu.add(targetShapeMenu);
		JMenu targetMaterialMenu = new JMenu("Material");
		targetMaterialMenu.setMnemonic(KeyEvent.VK_M); // Shortcut is 'M'
		ButtonGroup targetMaterialRadioButtons = new ButtonGroup();
		int numOfMaterials = Viewport.getNumOfMaterials();
		String[] materials = Viewport.getMaterials();
		double[] refractiveIndices = Viewport.getRefractiveIndices();
		ActionListener targetMaterialListener = new ActionListener() { // Adapter class
			
			/**
			 * Called when a radio button/menu item in the Material menu is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				JRadioButtonMenuItem source = (JRadioButtonMenuItem)(event.getSource());
				viewport.setTargetMaterial(Integer.parseInt(source.getActionCommand())); // Each menu item has a string which will contain the index of the material it corresponds to
			}
			
		};
		
		JMenu worldMenu = new JMenu("World");
		ButtonGroup worldMaterialRadioButtons = new ButtonGroup();
		ActionListener worldMaterialListener = new ActionListener() { // Adapter class
			
			/**
			 * Called when a radio button/menu item in the World menu is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				JRadioButtonMenuItem source = (JRadioButtonMenuItem)(event.getSource());
				viewport.setWorldMaterial(Integer.parseInt(source.getActionCommand())); // Each menu item has a string with the index of the material just as in the target's material menu
			}
			
		};
		
		for (int i = 0; i < numOfMaterials; i++) { // For each material generate a target and world menu item
			String label = materials[i] + " (" + refractiveIndices[i] + ")"; // Add the refractive index in parentheses after the material's name
			String actionCommand = Integer.toString(i); // Associate each menu item with the material's index
			
			JRadioButtonMenuItem targetMenuItem = new JRadioButtonMenuItem(label);
			targetMenuItem.setActionCommand(actionCommand);
			if (viewport.getTargetMaterial() == i) {
				targetMenuItem.setSelected(true); // Select the menu item matching the target's current material
			}
			targetMenuItem.addActionListener(targetMaterialListener);
			targetMaterialRadioButtons.add(targetMenuItem);
			targetMaterialMenu.add(targetMenuItem);
			
			JRadioButtonMenuItem worldMenuItem = new JRadioButtonMenuItem(label);
			worldMenuItem.setActionCommand(actionCommand);
			if (Viewport.getWorldMaterial() == i) {
				worldMenuItem.setSelected(true); // Select the menu item matching the world's current material
			}
			worldMenuItem.addActionListener(worldMaterialListener);
			worldMaterialRadioButtons.add(worldMenuItem);
			worldMenu.add(worldMenuItem);
		}
		targetMenu.add(targetMaterialMenu);
		menuBar.add(targetMenu);
		menuBar.add(worldMenu);
	}
	
	/**
	 * Generates and returns the View menu which is to be part of the menu bar
	 * @return the View menu
	 */
	private JMenu getViewMenu() {
		JMenu viewMenu = new JMenu("View");
		JCheckBoxMenuItem perspectiveCheckBox = new JCheckBoxMenuItem("Perspective"); // The checkbox is automatically toggled when selected
		perspectiveCheckBox.setMnemonic(KeyEvent.VK_P); // Shortcut is 'P'
		if (!viewport.isOrthographic()) {
			perspectiveCheckBox.setSelected(true); // Check the checkbox if perspective projection is being used
		}
		perspectiveCheckBox.addActionListener(new ActionListener() { // Adapter class
			
			/**
			 * Called when the perspective checkbox/menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.toggleOrthographic();
			}
			
		});
		viewMenu.add(perspectiveCheckBox);
		JCheckBoxMenuItem radiansCheckBox = new JCheckBoxMenuItem("Angles in radians");
		radiansCheckBox.setMnemonic(KeyEvent.VK_A); // Shortcut is 'A'
		if (!viewport.areAnglesInDegrees()) {
			radiansCheckBox.setSelected(true); // Check the checkbox if angles are being displayed in radians
		}
		radiansCheckBox.addActionListener(new ActionListener() {
			
			/**
			 * Called when the angles in radians checkbox/menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.toggleAngleUnits();
			}
			
		});
		viewMenu.add(radiansCheckBox);
		
		viewMenu.add(getCameraPositionsMenu()); // Add a submenu
		return viewMenu;
	}
	
	/**
	 * Generates and returns the menu of preset camera positions/orientations which is to be a submenu of the View menu
	 * @return the menu of camera positions/orientations
	 */
	private JMenu getCameraPositionsMenu() {
		JMenu cameraMenu = new JMenu("Camera position"); // Submenu of View menu
		cameraMenu.setMnemonic(KeyEvent.VK_C); // Shortcut is 'C'
		JMenuItem frontView = new JMenuItem("Front (shortcut 1)", KeyEvent.VK_F); // Menu item of Camera position submenu; shortcut is 'F' within the submenu - 1 is the shortcut from the viewport
		frontView.addActionListener(new ActionListener() { // Adapter class
			
			/**
			 * Called when the front menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.setViewFront();
			}
			
		});
		cameraMenu.add(frontView);
		JMenuItem backView = new JMenuItem("Back (shortcut 2)", KeyEvent.VK_B); // Shortcut from submenu is 'B'
		backView.addActionListener(new ActionListener() { // Adapter class
			
			/**
			 * Called when the back menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.setViewBack();
			}
			
		});
		cameraMenu.add(backView);
		JMenuItem leftView = new JMenuItem("Left (shortcut 3)", KeyEvent.VK_L); // Shortcut is 'L'
		leftView.addActionListener(new ActionListener() { // Adapter class
			
			/**
			 * Called when the left menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.setViewLeft();
			}
			
		});
		cameraMenu.add(leftView);
		JMenuItem rightView = new JMenuItem("Right (shortcut 4)", KeyEvent.VK_R); // Shortcut is 'R'
		rightView.addActionListener(new ActionListener() { // Adapter class
			
			/**
			 * Called when the right menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.setViewRight();
			}
			
		});
		cameraMenu.add(rightView);
		JMenuItem topView = new JMenuItem("Top (shortcut 5)", KeyEvent.VK_T); // Shortcut is 'T'
		topView.addActionListener(new ActionListener() { // Adapter class
			
			/**
			 * Called when the top menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.setViewTop();
			}
			
		});
		cameraMenu.add(topView);
		JMenuItem bottomView = new JMenuItem("Bottom (shortcut 6)", KeyEvent.VK_B); // Shortcut is 'B'
		bottomView.addActionListener(new ActionListener() { // Adapter class
			
			/**
			 * Called when the back menu item is clicked (or selected using the keyboard)
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.setViewBottom();
			}
			
		});
		cameraMenu.add(bottomView);
		return cameraMenu;
	}
	
	/**
	 * Returns the last menu bar that was generated by createMenuBar()
	 * @return the most recent menu bar that was generated by a call to createMenuBar()
	 */
	public JMenuBar getMenuBar() {
		return menuBar;
	}

	private final static int SLIDER_MAX = 150; // The maximum value of each slider; the minimum value is -SLIDER_MAX. Slider values are not in standard angular units and must be converted to radians for processing
	
	/**
	 * Generates a properties panel that can be retrieved by getPropertiesPanel()
	 * @param rayBox the selected ray box
	 */
	public void buildPropertiesPanel(RayBox rayBox) {
		propertiesPanel = new JPanel();
		propertiesPanel.setBackground(new Color(220, 220, 220)); // Set the background to light grey
		propertiesPanel.setLayout(new FlowLayout(FlowLayout.LEFT, 5, 5));
		propertiesPanel.setPreferredSize(new Dimension(PROPS_PANEL_WIDTH, fullHeight - (int)(menuBar.getPreferredSize().getHeight())));
		
		if (rayBox != null) { // If a ray box is selected (otherwise the properties panel is empty
			JPanel labelPanel = getLabelPanel(rayBox);
			propertiesPanel.add(labelPanel);
			
			JPanel anglesPanel = getDisplayAnglesPanel(rayBox);
			propertiesPanel.add(anglesPanel);
			
			JPanel beamThicknessPanel = getBeamThicknessPanel(rayBox);
			propertiesPanel.add(beamThicknessPanel);
			
			// Add a horizontal line to separate the upper and lower sections of the properties panel
			JSeparator horizontalLine = new JSeparator(SwingConstants.HORIZONTAL);
			horizontalLine.setPreferredSize(new Dimension(PROPS_PANEL_WIDTH - 10, 15));
			propertiesPanel.add(horizontalLine);
			
			// Calculate the height in pixels of the remaining section of the properties panel
			int heightRemaining = (int)(propertiesPanel.getPreferredSize().getHeight() - labelPanel.getPreferredSize().getHeight() - anglesPanel.getPreferredSize().getHeight() - beamThicknessPanel.getPreferredSize().getHeight() - horizontalLine.getPreferredSize().getHeight() - 40);
			
			JPanel globalPanel = new JPanel();
			TitledBorder title = BorderFactory.createTitledBorder("Global position/orientation"); // Give globalPanel a border with a title
			globalPanel.setBorder(title);
			globalPanel.setOpaque(false);
			globalPanel.setLayout(new FlowLayout(3, 3, FlowLayout.LEFT));
			int halfHeight = heightRemaining / 2;
			globalPanel.setPreferredSize(new Dimension(PROPS_PANEL_WIDTH - 10, halfHeight));
			
			Vector origin = rayBox.getOrigin();
			double globalHeading = (Math.PI / 2) - Math2.atan(origin.getElement(2), origin.getElement(0)); // Calculate the global heading of the selected ray box in radians
			if (globalHeading > Math.PI) {
				globalHeading = globalHeading - (2 * Math.PI); // Wrap the heading to the range -pi to pi
			}
			
			JPanel globalHeadingPanel = new JPanel();
			globalHeadingPanel.setPreferredSize(new Dimension(100, (int)(halfHeight - 30)));
			globalHeadingPanel.setOpaque(false);
			globalHeadingPanel.setLayout(new FlowLayout(20, 20, FlowLayout.LEFT));
			JLabel headingLabel = new JLabel("Heading");
			headingLabel.setPreferredSize(new Dimension(120, 20));
			globalHeadingPanel.add(headingLabel);
			
			JSlider globalHeadingSlider = getHeadingSlider(halfHeight, globalHeading);
			globalHeadingSlider.setName("globalHeading"); // The SliderListener will use this name to identify the type of slider
			globalHeadingPanel.add(globalHeadingSlider);
			globalPanel.add(globalHeadingPanel);
			
			double globalPitch = Math.asin(origin.getElement(1) / origin.modulus());
			
			JPanel globalPitchPanel = new JPanel();
			globalPitchPanel.setPreferredSize(new Dimension(100, (int)(halfHeight - 30)));
			globalPitchPanel.setOpaque(false);
			globalPitchPanel.setLayout(new FlowLayout(20, 20, FlowLayout.LEFT));
			JLabel pitchLabel = new JLabel("  Pitch");
			pitchLabel.setPreferredSize(new Dimension(120, 20));
			globalPitchPanel.add(pitchLabel);
			
			JSlider globalPitchSlider = getPitchSlider(halfHeight, globalPitch);
			globalPitchSlider.setName("globalPitch");
			globalPitchPanel.add(globalPitchSlider);
			globalPanel.add(globalPitchPanel);
			propertiesPanel.add(globalPanel);
			
			JPanel localPanel = new JPanel();
			title = BorderFactory.createTitledBorder("Local Orientation");
			localPanel.setBorder(title);
			localPanel.setOpaque(false);
			localPanel.setLayout(new FlowLayout(3, 3, FlowLayout.LEFT));
			localPanel.setPreferredSize(new Dimension(PROPS_PANEL_WIDTH - 10, halfHeight));
					
			EulerTriple orientation = rayBox.getOrientation().eulerObToUp();
			
			JPanel localHeadingPanel = new JPanel();
			localHeadingPanel.setPreferredSize(new Dimension(100, (int)(halfHeight - 30)));
			localHeadingPanel.setOpaque(false);
			localHeadingPanel.setLayout(new FlowLayout(20, 20, FlowLayout.LEFT));
			JLabel localHeadingLabel = new JLabel("Heading");
			localHeadingLabel.setPreferredSize(new Dimension(120, 20));
			localHeadingPanel.add(localHeadingLabel);
			
			JSlider localHeadingSlider = getHeadingSlider(halfHeight, orientation.getHeading()); // The heading of orientation is the local heading
			localHeadingSlider.setName("localHeading");
			localHeadingPanel.add(localHeadingSlider);
			localPanel.add(localHeadingPanel);
			
			JPanel localPitchPanel = new JPanel();
			localPitchPanel.setPreferredSize(globalHeadingPanel.getPreferredSize());
			localPitchPanel.setOpaque(false);
			localPitchPanel.setLayout(new FlowLayout(20, 20, FlowLayout.LEFT));
			JLabel localPitchLabel = new JLabel("  Pitch");
			localPitchLabel.setPreferredSize(new Dimension(120, 20));
			localPitchPanel.add(localPitchLabel);
			
			JSlider localPitchSlider = getPitchSlider(halfHeight, -orientation.getPitch()); // It is more intuitive for the user if pitch represents the angle above the horizontal rather than below it as it does in the code
			localPitchSlider.setName("localHeading");
			localPitchPanel.add(localPitchSlider);
			localPanel.add(localPitchPanel);
			
			if (rayBox.isLocalPitchInverted()) {
				localPitchSlider.setName("localPitchInv");
			} else { // This is the usual case. Local pitch is inverted when the local pitch goes beyond -pi/2 or pi/2 so that the ray box is always 'the right way up' and pitch is always the angle above the horizontal
				localPitchSlider.setName("localPitch");
			}
			
			localPitchSlider.addChangeListener(new SliderListener(-orientation.getPitch())); // The SliderListener needs to know the original angle so that it can calculate the change in angle when the slider is dragged and therefore the transformation to apply to the ray box
			localHeadingSlider.addChangeListener(new SliderListener(orientation.getHeading()));
			globalHeadingSlider.addChangeListener(new SliderListener(globalHeading, localHeadingSlider));
			globalPitchSlider.addChangeListener(new SliderListener(globalPitch, localPitchSlider, localHeadingSlider, rayBox));
			propertiesPanel.add(localPanel);
		}
	}
	
	/**
	 * Generates and returns the panel for setting the label of the selected ray box or deleting the selected ray box
	 * @param rayBox the selected ray box
	 * @return the panel containing a label, a text field and a delete button
	 */
	private JPanel getLabelPanel(RayBox rayBox) {
		JPanel labelPanel = new JPanel();
		labelPanel.setPreferredSize(new Dimension(PROPS_PANEL_WIDTH, 30)); // Set width to that of the properties panel and height to 30 pixels
		labelPanel.setOpaque(false); // No background colour
		labelPanel.setLayout(new FlowLayout(3, 3, FlowLayout.LEFT));
		labelPanel.add(new JLabel("Label:"));
		JTextField labelInput = new JTextField(rayBox.getLabel(), 10); // Set the text contents to the selected ray box's label
		labelInput.setMargin(new Insets(2, 2, 2, 2));
		ActionListener labelActionListener = new ActionListener() { // Adapter class
			
			/**
			 * Updates the label of the selected ray box when a new label is entered in the text field
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				JTextField source = (JTextField)(event.getSource());
				viewport.updateLabel(source.getText());
			}
			
		};
		labelInput.addActionListener(labelActionListener);
		labelInput.addFocusListener(new TextFieldFocusListener(labelActionListener)); // The TextFieldFocusListener requires the field's ActionListener so that a FocusEvent can trigger an ActionEvent
		labelPanel.add(labelInput);
		JButton delete = new JButton("Delete");
		delete.setMargin(new Insets(1, 3, 1, 3));
		ActionListener deleteActionListener = new ActionListener() { // Adapter class
			
			/**
			 * Called when the Delete button is clicked
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.removeRayBox();
			}
			
		};
		delete.addActionListener(deleteActionListener);
		labelPanel.add(delete);
		return labelPanel;
	}
	
	/**
	 * Generates and returns the panel containing the checkbox indicating whether angles are displayed for the selected ray box
	 * @param rayBox the selected ray box
	 * @return the display angles panel
	 */
	private JPanel getDisplayAnglesPanel(RayBox rayBox) {
		JPanel anglesPanel = new JPanel();
		anglesPanel.setPreferredSize(new Dimension(PROPS_PANEL_WIDTH, 30));
		anglesPanel.setOpaque(false);
		anglesPanel.setLayout(new FlowLayout(3, 3, FlowLayout.LEFT));
		JCheckBox anglesCheckBox = new JCheckBox("Display angles");
		anglesCheckBox.setSelected(rayBox.getAnglesVisible()); // Check the Display angles checkbox if angles are being displayed for the selected ray box
		ActionListener checkBoxListener = new ActionListener() { // Adapter class
			
			/**
			 * Called when the Display angles checkbox is toggled
			 * @param event contains details of the action that triggered this event
			 */
			public void actionPerformed(ActionEvent event) {
				viewport.toggleShowAngles();
			}
			
		};
		anglesCheckBox.addActionListener(checkBoxListener);
		anglesCheckBox.setOpaque(false);
		anglesPanel.add(anglesCheckBox);
		return anglesPanel;
	}
	
	/**
	 * Generates and returns the panel containing a beam thickness input field, label and increment and decrement buttons
	 * @param rayBox the selected ray box
	 * @return the panel containing components relating to the beam thickness setting of the selected ray box
	 */
	private JPanel getBeamThicknessPanel(RayBox rayBox) {
		JPanel beamThicknessPanel = new JPanel();
		beamThicknessPanel.setPreferredSize(new Dimension(PROPS_PANEL_WIDTH, 30));
		beamThicknessPanel.setOpaque(false);
		beamThicknessPanel.setLayout(new FlowLayout(0, 0, FlowLayout.LEFT));
		
		JLabel beamThicknessLabel = new JLabel("Beam thickness: ");
		beamThicknessPanel.add(beamThicknessLabel);
		
		JTextField inputField = new JTextField(String.valueOf(rayBox.getBeamThickness()), 3); // Set the contents of the Beam thickness field to the current beam thickness for the beam corresponding to the selected ray box
		inputField.setMargin(new Insets(2, 2, 2, 2));
		ActionListener actionListener = new BeamThicknessActionListener(String.valueOf(rayBox.getBeamThickness())); // Pass the starting value of the Beam thickness field
		inputField.addActionListener(actionListener);
		inputField.addFocusListener(new TextFieldFocusListener(actionListener));
		beamThicknessPanel.add(inputField);
		
		JPanel incDecButtons = new JPanel();
		incDecButtons.setLayout(new GridLayout(2, 1));
		incDecButtons.setPreferredSize(new Dimension(20, 30));
		
		JButton increment = new JButton("+");
		increment.setMargin(new Insets(0, 0, 0, 0));
		increment.setActionCommand("Increment");
		increment.addActionListener(new IncDecActionListener(inputField)); // Pass the Beam thickness field so that its value can be incremented by 1 when the + button is clicked
		
		JButton decrement = new JButton("-");
		decrement.setMargin(new Insets(0, 0, 0, 0));
		decrement.setActionCommand("Decrement");
		decrement.addActionListener(new IncDecActionListener(inputField));
		
		incDecButtons.add(increment);
		incDecButtons.add(decrement);
		beamThicknessPanel.add(incDecButtons);
		return beamThicknessPanel;
	}
	
	/**
	 * Generates and returns a labelled vertical slider between -SLIDER_MAX (representing -pi radians) and SLIDER_MAX (representing pi radians) with the initial value as heading converted from radians. Labels are in the angular units specified by the user (degrees or radians) and ticks indicate increments on the slider
	 * @param parentHeight the height in pixels of the component that is to contain the slider
	 * @param heading the global or local heading angle of the selected ray box in radians
	 * @return the slider representing a local or global heading of the selected ray box
	 */
	private JSlider getHeadingSlider(int parentHeight, double heading) {
		JSlider headingSlider = new JSlider(JSlider.VERTICAL, -SLIDER_MAX, SLIDER_MAX, (int)(Math.round(SLIDER_MAX * heading / Math.PI))); // Create a vertical slider between -SLIDER_MAX (representing -pi radians) and SLIDER_MAX (pi radians) currently set to the value that represents heading radians
		headingSlider.setOpaque(false);
		headingSlider.setPreferredSize(new Dimension(100, (int)(parentHeight - 50)));
		headingSlider.setMajorTickSpacing(SLIDER_MAX / 2); // Use longer lines to mark -pi, 0 and pi
		headingSlider.setMinorTickSpacing(SLIDER_MAX / 10); // Use shorter lines to mark -pi, -9pi/10, -8pi/10, ... 9pi/10, pi; major ticks replace minor ticks where they overlap
		headingSlider.setPaintTicks(true);
		Hashtable labelTable = new Hashtable(); // Use custom labels for points on the slider since generated labels would be in non-standard units
		// Specify slider values to display labels at and give the label for each
		if (viewport.areAnglesInDegrees()) { // Use labels in degrees if angles are to be displayed in degrees
			labelTable.put(new Integer(-SLIDER_MAX), new JLabel("-180\u00B0")); // \u00B0 represents the degree symbol
			labelTable.put(new Integer(-SLIDER_MAX / 2), new JLabel("-90\u00B0"));
			labelTable.put(new Integer(0), new JLabel("0\u00B0"));
			labelTable.put(new Integer(SLIDER_MAX / 2), new JLabel("90\u00B0"));
			labelTable.put(new Integer(SLIDER_MAX), new JLabel("180\u00B0"));
			headingSlider.setLabelTable(labelTable);
		} else {
			labelTable.put(new Integer(-SLIDER_MAX), new JLabel("-\u03C0")); // \u030C0 represents the pi symbol
			labelTable.put(new Integer(-SLIDER_MAX / 2), new JLabel("-\u03C0/2")); // -pi/2
			labelTable.put(new Integer(0), new JLabel("0"));
			labelTable.put(new Integer(SLIDER_MAX / 2), new JLabel("\u03C0/2")); // pi/2
			labelTable.put(new Integer(SLIDER_MAX), new JLabel("\u03C0")); // pi
			headingSlider.setLabelTable(labelTable);
		}
		headingSlider.setPaintLabels(true);
		return headingSlider;
	}
	
	/**
	 * Generates and returns a labelled vertical slider between -SLIDER_MAX (representing -pi/2 radians) and SLIDER_MAX (representing pi/2 radians) with the initial value as pitch converted from radians. Labels are in the angular units specified by the user (degrees or radians) and ticks indicate increments on the slider
	 * @param parentHeight the height in pixels of the component that is to contain the slider
	 * @param pitch the global or local pitch angle of the selected ray box in radians
	 * @return the slider representing a local or global pitch of the selected ray box
	 */
	private JSlider getPitchSlider(int parentHeight, double pitch) {	
		JSlider pitchSlider = new JSlider(JSlider.VERTICAL, -SLIDER_MAX, SLIDER_MAX, (int)(Math.round(2 * SLIDER_MAX * pitch / Math.PI)));
		pitchSlider.setOpaque(false);
		pitchSlider.setPreferredSize(new Dimension(100, (int)(parentHeight - 50)));
		pitchSlider.setMajorTickSpacing(SLIDER_MAX / 2);
		pitchSlider.setMinorTickSpacing(SLIDER_MAX / 10);
		pitchSlider.setPaintTicks(true);
		Hashtable labelTable = new Hashtable();
		if (viewport.areAnglesInDegrees()) {
			labelTable.put(new Integer(-SLIDER_MAX), new JLabel("-90\u00B0")); // \u00B0 represents the degree symbol
			labelTable.put(new Integer(-SLIDER_MAX / 2), new JLabel("-45\u00B0"));
			labelTable.put(new Integer(0), new JLabel("0\u00B0"));
			labelTable.put(new Integer(SLIDER_MAX / 2), new JLabel("45\u00B0"));
			labelTable.put(new Integer(SLIDER_MAX), new JLabel("90\u00B0"));
			pitchSlider.setLabelTable(labelTable);
		} else {
			labelTable.put(new Integer(-SLIDER_MAX), new JLabel("-\u03C0/2")); // \u03C0 represents the pi symbol
			labelTable.put(new Integer(-SLIDER_MAX / 2), new JLabel("-\u03C0/4"));
			labelTable.put(new Integer(0), new JLabel("0"));
			labelTable.put(new Integer(SLIDER_MAX / 2), new JLabel("\u03C0/4"));
			labelTable.put(new Integer(SLIDER_MAX), new JLabel("\u03C0/2"));
			pitchSlider.setLabelTable(labelTable);
		}
		pitchSlider.setPaintLabels(true);
		return pitchSlider;
	}
	
	/**
	 * Returns the properties panel generated by the last call to buildPropertiesPanel
	 * @return the properties panel generated by the last call to buildPropertiesPanel
	 */
	public JPanel getPropertiesPanel() {
		return propertiesPanel;
	}
	
	/**
	 * Class for ActionListeners of buttons that increment or decrement the value in a JTextField by 1
	 * @author William Platt
	 *
	 */
	private class IncDecActionListener implements ActionListener {
		
		private JTextField textField;
		
		/**
		 * Constructor for the IncDecActionListener class
		 * @param textField the text field that an ActionEvent increments or decrements the value of
		 */
		public IncDecActionListener(JTextField textField) {
			this.textField = textField;
		}
		
		/**
		 * Called when the button is clicked and increments or decrements the value in textField by 1
		 * @param event contains details of the action that triggered this event
		 */
		public void actionPerformed(ActionEvent event) {
			JButton button = (JButton)(event.getSource());
			if (button.getActionCommand().equals("Increment")) {
				textField.setText(String.valueOf(Integer.parseInt(textField.getText()) + 1)); // Convert the current entry to from a String to an integer, add 1 and convert back to a String to set as the contents of the text field
			} else if (button.getActionCommand().equals("Decrement")) {
				textField.setText(String.valueOf(Integer.parseInt(textField.getText()) - 1));
			}
			textField.requestFocusInWindow(); // Give the text field focus so that the FocusListener triggers an ActionEvent which will validate the new value and also so that it is easier for the user to type a new value
		}
		
	}
	
	/**
	 * Class for FocusListeners of text fields that need to trigger an ActionEvent when they lose or gain focus
	 * @author William Platt
	 *
	 */
	private class TextFieldFocusListener implements FocusListener {
		
		private ActionListener actionListener;
		
		/**
		 * Constructor for the TextFieldFocusListener class
		 * @param actionListener the ActionListener of the text field
		 */
		public TextFieldFocusListener(ActionListener actionListener) {
			super();
			this.actionListener = actionListener;
		}
		
		/**
		 * Called when the text field gains focus to trigger an ActionEvent
		 * @param event contains details of the action that triggered this event
		 */
		public void focusGained(FocusEvent event) {
			focusLost(event);
		}
		
		/**
		 * Called when the text field loses focus to trigger an ActionEvent
		 * @param event contains details of the action that triggered this event
		 */
		public void focusLost(FocusEvent event) {
			actionListener.actionPerformed(new ActionEvent(event.getSource(), ActionEvent.ACTION_PERFORMED, null) {});
		}
		
	}
	
	/**
	 * Class for ActionListeners of beam thickness text fields that validates the data entered, rounding to an appropriate value or reverting to the last appropriate value
	 * @author William Platt
	 *
	 */
	private class BeamThicknessActionListener implements ActionListener {
		
		private String lastValid;
		
		/**
		 * Constructor for the BeamThicknessActionListener class
		 * @param initialString the initial string in the text field
		 */
		public BeamThicknessActionListener(String initialString) {
			 lastValid = initialString;
		}
		
		/**
		 * Called when the text field gains or loses focus or the user hits enter with it in focus
		 * @param event contains details of the action that triggered this event
		 */
		public void actionPerformed(ActionEvent event) {
			JTextField source = (JTextField)(event.getSource());
			try {
				int newBeamThickness = (int)(Math.round(Double.parseDouble(source.getText()))); // Round to the nearest integer
				// Values below 1 become 1 and those above 10 become 10
				if (newBeamThickness < 1) {
					newBeamThickness = 1;
				} else if (newBeamThickness > 10) {
					newBeamThickness = 10;
				}
				String newText = Integer.toString(newBeamThickness);
				source.setText(newText);
				viewport.updateBeamThickness(newBeamThickness);
				lastValid = newText; // Store the most recent valid entry so that an non-numerical entry can be reverted to this
			} catch (Exception e) { // If the contents of the text field is non-numerical (causing parseDouble() to throw an exception)
				source.setText(lastValid); // Revert to the last valid entry
			}
		}
	}
	
	/**
	 * Class for ActionListeners of material name input fields that restricts the name to 30 characters with no whitespace at the beginning or end (blank string replaced with "Custom material")
	 * @author William Platt
	 *
	 */
	private class MaterialNameActionListener implements ActionListener {
		
		/**
		 * Called when the text field loses or gains focus or the user hits enter with it in focus
		 * @param event contains details of the action that triggered this event
		 */
		public void actionPerformed(ActionEvent event) {
			JTextField source = (JTextField)(event.getSource());
			if (!source.hasFocus()) { // Only validate and sanitise when the text field has just lost focus
				String name = source.getText().trim(); // Store name with whitespace at the beginning and end removed
				if (name.length() > 30) {
					name = name.substring(0, 30).trim(); // Store the trimmed (the end has changed so needs trimming again) first 30 characters of the trimmed name
				}
				if (name.equals("")) {
					source.setText("Custom material"); // Replace a blank name with "Custom material"
				} else {
					source.setText(name);
				}
			}
		}
		
	}
	
	/**
	 * Class for ActionListeners of refractive index input fields that restricts values between 1.0 and 100.0 inclusive and reverts non-numerical input to the last valid value
	 * @author William Platt
	 *
	 */
	private class RefractiveIndexActionListener implements ActionListener {
		
		private String lastValid;
		
		/**
		 * Constructor for the RefractiveIndexActionListener class
		 * @param initialString the initial contents of the text field
		 */
		public RefractiveIndexActionListener(String initialString) {
			lastValid = initialString;
		}
		
		/**
		 * Called when the text field loses or gains focus or the user hits enter with it in focus
		 * @param event contains details of the action that triggered this event
		 */
		public void actionPerformed(ActionEvent event) {
			JTextField source = (JTextField)(event.getSource());
			try {
				double newRefractiveIndex = Double.parseDouble(source.getText());
				if (newRefractiveIndex < 1.0) {
					newRefractiveIndex = 1.0; // Inputs below 1 are changed to 1
				} else if (newRefractiveIndex > 100) {
					newRefractiveIndex = 100; // Inputs above 100 are changed to 100
				}
				String newText = Double.toString(newRefractiveIndex);
				source.setText(newText);
				lastValid = newText; // Store the most recent valid entry so that a non-numerical entry can be reverted to this value
			} catch (Exception e) { // If the input is not numerical (causing parseDouble() to throw an exception)
				source.setText(lastValid);
			}
		}
		
	}
	
	/**
	 * Class for ChangeListeners of sliders that apply the relevant transformation to the selected ray box while the slider is being dragged
	 * @author William Platt
	 *
	 */
	private class SliderListener implements ChangeListener {
		
		private double prevValue;
		private JSlider parallelSlider;
		private JSlider secondaryParallelSlider;
		private RayBox rayBox;
		
		/**
		 * A constructor for SliderListeners that apply to sliders which don't have any affect on other sliders. These are the local orientation sliders
		 * @param previousValue the initial value of the slider converted to radians
		 */
		public SliderListener(double previousValue) {
			prevValue = previousValue;
		}
		
		/**
		 * A constructor for a SliderListener that applies to a slider which affects one other slider (the global heading slider affects the local heading)
		 * @param previousValue the initial value of the slider this object is to be a listener for in radians
		 * @param affectedSlider the slider which is affected by changes to the other slider
		 */
		public SliderListener(double previousValue, JSlider affectedSlider) {
			prevValue = previousValue;
			parallelSlider = affectedSlider;
			secondaryParallelSlider = null;
		}
		
		/**
		 * A constructor for a SliderListener that applies to a slider which affects one other slider and occasionally a second other slider (the global pitch slider directly and sometimes needs to change the local heading)
		 * @param previousValue the initial value of the slider this object is to be a listener for in radians
		 * @param directlyAffectedSlider the slider which is always affected by changes to the slider being listened for
		 * @param indirectlyAffectedSlider the slider that is sometimes affected by changes to the slider being listened for
		 * @param rayBox the selected ray box
		 */
		public SliderListener(double previousValue, JSlider directlyAffectedSlider, JSlider indirectlyAffectedSlider, RayBox rayBox) {
			prevValue = previousValue;
			parallelSlider = directlyAffectedSlider;
			secondaryParallelSlider = indirectlyAffectedSlider;
			this.rayBox = rayBox;
		}
		
		/**
		 * Called when the slider is dragged (including while it is still being dragged) or the value changed by another slider that affects it
		 * @param event contains details of the action that triggered this event
		 */
		public void stateChanged(ChangeEvent event) {
			JSlider source = (JSlider)(event.getSource());
			int sliderValue = source.getValue();
			switch (source.getName()) {
				case "globalHeading":
					updateParallelSlider(sliderValue); // Change the slider that is affected by this one (local heading slider)
					viewport.globallyRotateRayBox(headingFromSliderVal(sliderValue), 0);
					break;
				case "globalPitch":
					updateParallelSlider(sliderValue); // Change the slider that is affected by this one (local pitch and maybe local heading)
					viewport.globallyRotateRayBox(0, pitchFromSliderVal(sliderValue));
					break;
				case "localHeading":
					if (source.getValueIsAdjusting()) { // If the slider was changed by the user
						viewport.locallyRotateRayBox(headingFromSliderVal(sliderValue), 0); // Calculates the change in heading in radians and stores the new heading, then the ray box is transformed by locallyRotateRayBox()
					} else { // The transformation is to be handled by the slider that affects this one
						prevValue = sliderValue * Math.PI / SLIDER_MAX; // Store the most recent heading in radians
					}
					break;
				case "localPitch":
					if (source.getValueIsAdjusting()) {
						viewport.locallyRotateRayBox(0, -pitchFromSliderVal(sliderValue)); // The code interprets pitch as the angle below the horizontal, so the pitch must be negated for use in transformations
					} else { // Transformation handled by the slider that affects this one
						prevValue = sliderValue * Math.PI / (2 * SLIDER_MAX); // Store the most recent pitch in radians as pitchFromSliderVal() would normally do
					}
					break;
				case "localPitchInv": // If the ray box is upside down (object y-axis pointing below the horizontal); this is not obvious to the user because the ray box is a cube and no axes are shown, so we treat the ray box as though it is still the right way up
					if (source.getValueIsAdjusting()) {
						viewport.locallyRotateRayBox(0, pitchFromSliderVal(sliderValue)); // Pitch needs to be negated twice, so no changes needed
					} else {
						prevValue = sliderValue * Math.PI / (2 * SLIDER_MAX);
					}
			}
		}
		
		/**
		 * Returns the change in heading in radians from the last time the slider was changed (or from when the slider was generated) and updates prevValue
		 * @param sliderValue the new value of the slider in non-standard units
		 * @return the change in heading in radians
		 */
		private double headingFromSliderVal(int sliderValue) {
			double newHeading = sliderValue * Math.PI / SLIDER_MAX; // Convert sliderValue to radians
			double changeInHeading = newHeading - prevValue;
			prevValue = newHeading; // Update prevValue for the next time the slider is changed
			return changeInHeading;
		}
		
		/**
		 * Returns the change in pitch in radians from the last time the slider was changed (or from when the slider was generated) and updates prevValue
		 * @param sliderValue the new value of the slider in non-standard units
		 * @return the change in pitch in radians
		 */
		private double pitchFromSliderVal(int sliderValue) {
			double newPitch = sliderValue * Math.PI / (2 * SLIDER_MAX);
			double changeInPitch = newPitch - prevValue;
			prevValue = newPitch;
			return changeInPitch;
		}
		
		/**
		 * For a global slider, this method changes the sliders it affects
		 * @param newSliderValue the new value of the slider this object is a listener for in non-standard units
		 */
		private void updateParallelSlider(int newSliderValue) {
			int changeInValue;
			if (secondaryParallelSlider != null) { // If this SliderListener is for a global pitch slider
				changeInValue = (int)(newSliderValue - Math.round(2 * SLIDER_MAX * prevValue / Math.PI)); // Calculate the slider's change in non-standard units
				int newValue0;
				if (parallelSlider.getName().equals("localPitch")) {
					newValue0 = parallelSlider.getValue() - changeInValue; // Increase in global pitch normally causes a decrease in local pitch
				} else { // if the name is "localPitchInv"
					newValue0 = parallelSlider.getValue() + changeInValue;
				}
				if (newValue0 > SLIDER_MAX) { // If the new pitch is off the top end of the slider
					newValue0 = 2 * SLIDER_MAX - newValue0; // The amount newValue0 was above SLIDER_MAX becomes how much it is below SLIDER_MAX
					invertPitchSlider();
				} else if (newValue0 < -SLIDER_MAX) { // If the new pitch is off the bottom end of the slider
					newValue0 = -newValue0 - 2 * SLIDER_MAX; // The amount newValue0 was under -SLIDER_MAX becomes how much it is above -SLIDER_MAX
					invertPitchSlider();
				}
				parallelSlider.setValue(newValue0);
			} else {
				changeInValue = (int)(newSliderValue - Math.round(SLIDER_MAX * prevValue / Math.PI));
				int newValue = parallelSlider.getValue() + changeInValue;
				// Wrap new heading so that the slider goes off the bottom and onto the top or vice versa
				if (newValue > SLIDER_MAX) {
					newValue -= 2 * SLIDER_MAX; // The amount above SLIDER_MAX becomes the amount above -SLIDER_MAX
				} else if (newValue < -SLIDER_MAX) {
					newValue += 2 * SLIDER_MAX; // The amount below -SLIDER_MAX becomes the amount below SLIDER_MAX
				}
				parallelSlider.setValue(newValue);
			}
		}
		
		/**
		 * For a global pitch slider, this method inverts the local pitch slider by changing its name, toggling a ray box property and adding or subtracting pi radians from the local heading
		 */
		private void invertPitchSlider() {
			if (parallelSlider.getName().equals("localPitch")) {
				parallelSlider.setName("localPitchInv"); // The ray box is no longer upside down, so local pitch needs to go down when global pitch goes up
			} else {
				parallelSlider.setName("localPitch"); // The ray box is now upside down, so local pitch needs to go up when global pitch goes up
			}
			rayBox.toggleLocalPitchInverted();
			
			int newValue1 = secondaryParallelSlider.getValue();
			// To avoid aliasing (where one orientation can be expressed in more than one way), the amount a pitch is outside the interval [-pi/2, pi/2] becomes the amount it is within the interval, and the heading is offset by pi and then a multiple of 2pi to keep it between -pi and pi
			newValue1 += SLIDER_MAX;
			if (newValue1 > SLIDER_MAX) {
				newValue1 -= 2 * SLIDER_MAX; // The previous heading was already canonical, so the heading only needs to be offset by 2pi at the most
			}
			secondaryParallelSlider.setValue(newValue1);
		}
		
	}
	
}
